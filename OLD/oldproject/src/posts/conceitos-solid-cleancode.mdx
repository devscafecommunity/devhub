---
author: Pedro K. Jesus
title: Clean Code com Princípios S.O.L.I.D
description: Como escrever código mais limpo, aderindo aos princípios S.O.L.I.D e a filosofia do clean code.
date: 23-09-2023
image: /postassets/conceitos-solid-cleancode/conceitos-solid-cleancode.png
cover: /postassets/conceitos-solid-cleancode/conceitos-solid-cleancode.png
---

# Clean Code com Princípios S.O.L.I.D

Quando se trata de escrever código de qualidade, existem várias diretrizes e princípios que podem nos ajudar a alcançar esse objetivo. Dois desses princípios amplamente reconhecidos são o "Clean Code" e os princípios S.O.L.I.D. Neste artigo, exploraremos como você pode escrever código mais limpo, aderindo aos princípios S.O.L.I.D.

## **Clean Code: O que é?**

"Clean Code" é um conceito popularizado por Robert C. Martin em seu livro de mesmo nome. Ele enfatiza a importância de escrever código que seja fácil de ler, entender e manter. O código limpo é aquele que comunica suas intenções de maneira clara e não tem complexidades desnecessárias.

## **Princípios S.O.L.I.D**

Os princípios S.O.L.I.D são um conjunto de cinco princípios de design de software que visam criar código robusto e de fácil manutenção. Eles são:

### **1. Single Responsibility Principle (SRP) - Princípio da Responsabilidade Única**

Este princípio afirma que uma classe deve ter apenas uma razão para mudar. Em outras palavras, uma classe deve ter uma única responsabilidade.

**Exemplo de aplicação:**

```python
# Antes
class Pedido:
    def calcular_total(self, itens):
        # Código para calcular o total

    def gerar_relatorio(self, itens):
        # Código para gerar um relatório

# Depois
class Pedido:
    def calcular_total(self, itens):
        # Código para calcular o total

class Relatorio:
    def gerar(self, itens):
        # Código para gerar um relatório
```

### **2. Open-Closed Principle (OCP) - Princípio Aberto-Fechado**

O OCP afirma que as entidades de software (classes, módulos, funções, etc.) devem estar abertas para extensão, mas fechadas para modificação.

**Exemplo de aplicação:**

```python
# Antes
class CalculadoraDeImpostos:
    def calcular(self, pedido):
        if pedido.tipo == 'normal':
            # Cálculo de imposto normal
        elif pedido.tipo == 'vip':
            # Cálculo de imposto VIP

# Depois
class CalculadoraDeImpostos:
    def calcular(self, pedido):
        # Lógica comum

class CalculadoraDeImpostosVIP(CalculadoraDeImpostos):
    def calcular(self, pedido):
        # Lógica específica para VIP
```

### **3. Liskov Substitution Principle (LSP) - Princípio da Substituição de Liskov**

Esse princípio afirma que objetos de uma classe derivada devem ser capazes de substituir objetos de uma classe base sem que o programa perca a consistência.

**Exemplo de aplicação:**

```python
# Antes
class Ave:
    def voar(self):
        pass

class Pinguim(Ave):
    def voar(self):
        # Pinguins não voam, mas precisam implementar o método

# Depois
class Ave:
    def voar(self):
        pass

class Pinguim(Ave):
    def voar(self):
        raise Exception("Pinguins não voam")
```

### **4. Interface Segregation Principle (ISP) - Princípio da Segregação de Interfaces**

O ISP afirma que uma classe não deve ser forçada a implementar métodos que ela não utiliza. Interfaces devem ser segregadas para serem mais específicas.

**Exemplo de aplicação:**

```python
# Antes
class Trabalhador:
    def trabalhar(self):
        pass

    def comer(self):
        pass

# Depois
class Trabalhador:
    def trabalhar(self):
        pass

class Comedor:
    def comer(self):
        pass
```

### **5. Dependency Inversion Principle (DIP) - Princípio da Inversão de Dependência**

Esse princípio afirma que módulos de alto nível não devem depender de módulos de baixo nível, ambos devem depender de abstrações. Além disso, abstrações não devem depender de detalhes, detalhes devem depender de abstrações.

**Exemplo de aplicação:**

```python
# Antes
class GerenciadorDePedidos:
    def __init__(self):
        self.repositorio = RepositorioDePedidos()

# Depois
class GerenciadorDePedidos:
    def __init__(self, repositorio):
        self.repositorio = repositorio
```

## **Conclusão**

Ao aplicar os princípios S.O.L.I.D juntamente com a filosofia do código limpo, você estará no caminho certo para escrever código mais legível, extensível e de fácil manutenção. Lembre-se de que esses princípios não são regras rígidas, mas diretrizes que podem ajudar a melhorar a qualidade do seu código. Pratique-os continuamente e adapte-os às necessidades específicas do seu projeto para alcançar um código de alta qualidade.